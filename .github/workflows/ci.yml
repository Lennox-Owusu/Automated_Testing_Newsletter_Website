name: CI - Selenium JUnit

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]

jobs:
  tests:
    runs-on: ubuntu-latest

    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: maven

      # Optional: Show Chrome/Java versions for debugging
      - name: Show tool versions
        run: |
          google-chrome --version || true
          java -version
          mvn -v

      # Run tests in headless mode (your BaseTest reads -Dheadless=true)
      - name: Run tests (headless)
        run: mvn -B -Dheadless=true clean test
        env:
          HTTP_PROXY: ""
          HTTPS_PROXY: ""



      # Always upload reports, even on failure
      - name: Upload Surefire test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: surefire-reports
          path: target/surefire-reports

      - name: Summarize test results
        if: always()
        run: |
          python3 - << 'PY'
          import os, glob, xml.etree.ElementTree as ET

          report_dir = "target/surefire-reports"
          files = glob.glob(os.path.join(report_dir, "TEST-*.xml"))

          total = failures = errors = skipped = 0
          first_fail_class = first_fail_method = first_fail_msg = ""

          print("üìå DEBUG: Found XML files:", files)

          for f in files:
              try:
                  print("üìå DEBUG: Parsing:", f)
                  root = ET.parse(f).getroot()

                  total    += int(root.attrib.get("tests", "0"))
                  failures += int(root.attrib.get("failures", "0"))
                  errors   += int(root.attrib.get("errors", "0"))
                  skipped  += int(root.attrib.get("skipped", "0"))

                  if not first_fail_class:
                      for tc in root.iter("testcase"):
                          fe = None

                          # direct failure/error
                          for tag in ("failure", "error"):
                              node = tc.find(tag)
                              if node is not None:
                                  fe = node
                                  break

                          # nested failure/error
                          if fe is None:
                              for node in tc.iter():
                                  if node.tag in ("failure", "error"):
                                      fe = node
                                      break

                          if fe is not None:
                              first_fail_class  = tc.attrib.get("classname", "")
                              first_fail_method = tc.attrib.get("name", "")

                              raw_msg = fe.attrib.get("message")
                              if raw_msg and raw_msg.strip():
                                  first_fail_msg = raw_msg.strip()
                              else:
                                  # CDATA extraction
                                  cdata = "".join(fe.itertext()).strip()
                                  first_fail_msg = cdata if cdata else "No failure message"

                              break

              except Exception as e:
                  print("‚ö†Ô∏è DEBUG: Parser error:", e)

          passed = max(total - failures - errors - skipped, 0)

          print("üìå DEBUG SUMMARY")
          print("TOTAL:", total)
          print("PASSED:", passed)
          print("FAILED:", failures)
          print("ERRORS:", errors)
          print("SKIPPED:", skipped)
          print("FAIL CLASS:", first_fail_class)
          print("FAIL METHOD:", first_fail_method)
          print("FAIL MSG:", first_fail_msg)

          with open(os.environ["GITHUB_ENV"], "a") as env:
              env.write(f"TOTAL_TESTS={total}\n")
              env.write(f"PASSED_TESTS={passed}\n")
              env.write(f"FAILED_TESTS={failures}\n")
              env.write(f"ERRORED_TESTS={errors}\n")
              env.write(f"SKIPPED_TESTS={skipped}\n")
              env.write(f"FIRST_FAIL_CLASS={first_fail_class}\n")
              env.write(f"FIRST_FAIL_METHOD={first_fail_method}\n")
              env.write(f"FIRST_FAIL_MSG={first_fail_msg}\n")
          PY
      # --- Notifications (failure only) ---

      - name: Slack notify on failure
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          REPO:   ${{ github.repository }}
          BRANCH: ${{ github.ref_name }}
          SHA:    ${{ github.sha }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          # Ensure jq exists (usually present on ubuntu-latest)
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

          echo "DEBUG FAIL CLASS: $FIRST_FAIL_CLASS"
          echo "DEBUG FAIL METHOD: $FIRST_FAIL_METHOD"
          echo "DEBUG FAIL MSG: $FIRST_FAIL_MSG"

          # Build JSON safely with jq (handles quotes/newlines)
          PAYLOAD=$(
            jq -n \
              --arg repo    "$REPO" \
              --arg branch  "$BRANCH" \
              --arg sha     "$SHA" \
              --arg run     "$RUN_URL" \
              --arg passed  "$PASSED_TESTS" \
              --arg total   "$TOTAL_TESTS" \
              --arg failed  "$FAILED_TESTS" \
              --arg errs    "$ERRORED_TESTS" \
              --arg skipped "$SKIPPED_TESTS" \
              --arg fclass  "$FIRST_FAIL_CLASS" \
              --arg fmethod "$FIRST_FAIL_METHOD" \
              --arg fmsg    "$FIRST_FAIL_MSG" \
              '{
                 text: "CI Failed ‚Äî Automated Tests",
                 blocks: [
                   { "type":"header",
                     "text": { "type":"plain_text", "text":"‚ùå CI Failed ‚Äî Automated Tests" } },
                   { "type":"section",
                     "fields": [
                       { "type":"mrkdwn", "text": ("*Repository:*\n" + $repo) },
                       { "type":"mrkdwn", "text": ("*Branch:*\n" + $branch) },
                       { "type":"mrkdwn", "text": ("*Commit:*\n" + $sha) },
                       { "type":"mrkdwn", "text": ("*Results:*\n" + $passed + "/" + $total + " passed, " + $failed + " failed, " + $errs + " errors, " + $skipped + " skipped") }
                     ]},
                   { "type":"section",
                     "fields": [
                       { "type":"mrkdwn", "text": ("*Failing Test:*\n" + $fclass + "." + $fmethod) },
                       { "type":"mrkdwn", "text": ("*Error:*\n" + $fmsg) }
                     ]},
                   { "type":"actions",
                     "elements": [
                       { "type":"button",
                         "text": { "type":"plain_text", "text":"View CI Run" },
                         "url": $run, "style":"danger" }
                     ]}
                 ]
               }'
          )

          # Send and print HTTP status for quick debugging
          curl -s -X POST -H "Content-type: application/json" \
            --data "$PAYLOAD" "$SLACK_WEBHOOK_URL" -w "\nHTTP %{http_code}\n"
          
      - name: Slack notify on success
        if: success()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          REPO:   ${{ github.repository }}
          BRANCH: ${{ github.ref_name }}
          SHA:    ${{ github.sha }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

          PAYLOAD=$(
            jq -n \
              --arg repo    "$REPO" \
              --arg branch  "$BRANCH" \
              --arg sha     "$SHA" \
              --arg run     "$RUN_URL" \
              --arg passed  "$PASSED_TESTS" \
              --arg total   "$TOTAL_TESTS" \
              --arg skipped "$SKIPPED_TESTS" \
              '{
                 text: "CI Passed ‚Äî Automated Tests",
                 blocks: [
                   { "type":"header",
                     "text": { "type":"plain_text", "text":"‚úÖ CI Passed ‚Äî Automated Tests" } },
                   { "type":"section",
                     "fields": [
                       { "type":"mrkdwn", "text": ("*Repository:*\n" + $repo) },
                       { "type":"mrkdwn", "text": ("*Branch:*\n" + $branch) },
                       { "type":"mrkdwn", "text": ("*Commit:*\n" + $sha) },
                       { "type":"mrkdwn", "text": ("*Results:*\n" + $passed + "/" + $total + " passed, " + $skipped + " skipped") }
                     ]},
                   { "type":"actions",
                     "elements": [
                       { "type":"button",
                         "text": { "type":"plain_text", "text":"View CI Run" },
                         "url": $run, "style":"primary" }
                     ]}
                 ]
               }'
          )

          curl -s -X POST -H "Content-type: application/json" \
            --data "$PAYLOAD" "$SLACK_WEBHOOK_URL" -w "\nHTTP %{http_code}\n"

      - name: Email notify on failure
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_HOST }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: "‚ùå CI failed ‚Äî ${{ github.repository }} @ ${{ github.ref_name }}"
          to: ${{ secrets.MAIL_TO }}
          from: ${{ secrets.MAIL_FROM }}
          secure: true
          html_body: |
            <h3>CI FAILED</h3>
            <p>Repository: ${{ github.repository }}</p>
            <p>Branch: ${{ github.ref_name }}</p>
            <p>Commit: ${{ github.sha }}</p>
            <p>Run: <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Run</a></p>

      - name: Summary
        if: always()
        run: |
            echo "### Selenium CI Summary" >> $GITHUB_STEP_SUMMARY
            echo "- Status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
            echo "- Branch: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
            echo "- Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
